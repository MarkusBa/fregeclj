module fregeclj.Fregeclj where

import frege.control.monad.trans.MonadIO
import frege.prelude.Math

{-- Idea: Frege sits on top!
     
     Steps if you have clojure code that depends on frege that depends on clojure:
     lein clean
     Change Frege class to not depend on clojure.
     lein fregec
     lein repl (or some other command that compiles the clojure code) like lein compile
     Change Frege class
     lein fregec
     
     Steps if you just call clojure
     lein clean
     lein compile
     lein fregec
     lein repl 
     (import ...)
     
     Even less steps
     lein clean
     lein compile
     lein fregec :run fregeclj.Fregeclj
--}

data List e = native java.util.List where
  native add :: Mutable s (List e) -> e -> ST s Bool
              | Mutable s (List e) -> Int -> e -> ST s ()
  native clear :: Mutable s (List e) -> ST s ()
  native contains :: Mutable s (List e) -> Object -> ST s Bool
  native equals :: Mutable s (List e) -> Object -> ST s Bool
  native get :: Mutable s (List e) -> Int -> ST s e
  native hashCode :: Mutable s (List e) -> ST s Int
  native indexOf :: Mutable s (List e) -> Object -> ST s Int
  native isEmpty :: Mutable s (List e) -> ST s Bool
  native lastIndexOf :: Mutable s (List e) -> Object -> ST s Int
  native remove :: Mutable s (List e) -> Object -> ST s Bool
                 | Mutable s (List e) -> Int -> ST s e
  native set :: Mutable s (List e) -> Int -> e -> ST s e
  native size :: Mutable s (List e) -> ST s Int
  native subList :: Mutable s (List e) -> Int -> Int -> STMutable s (List e)

data PersistentMap k v = native clojure.lang.IPersistentMap where
  pure native empty clojure.lang.PersistentHashMap.EMPTY :: PersistentMap k v
  pure native assoc :: PersistentMap k v -> k -> v -> PersistentMap k v
  pure native valAt :: PersistentMap k v -> k -> v -> v

  fromKVList :: [(k, v)] -> PersistentMap k v
  fromKVList xs = fold addItem PersistentMap.empty xs where
    addItem m (k, v) = PersistentMap.assoc m k v

data LazySeq v = native clojure.lang.LazySeq

data PersistentList v = native clojure.lang.IPersistentList 
--where
  --pure native empty clojure.lang.PersistentList.EMPTY :: PersistentList v
  --pure native cons :: PersistentList v -> v  -> PersistentList v

data Keyword = native clojure.lang.Keyword    

{--
   #^{:static true} [existingamount [long String Object] Long]
              #^{:static true} [updateitem [long String long Object] Integer]
              #^{:static true} [insertitem [String long double long  Object] Integer]
              #^{:static true} [deleteitem [long String Object] Integer]
              #^{:static true} [wrapintransaction [frege.runtime.Fun1] Object]
              #^{:static true} [getitems [long] clojure.lang.LazySeq]
 --}     
 
 -- TODO Stop lying about the methods being pure
 --           We currently have to lie because we are passing a lambda to clojure.  Since clojure doesn't know about laziness, the lambda isn't completely evaluated ??
                 
data DatabaseAccess = native com.fregeclj.DatabaseAccess where
  pure native getitems com.fregeclj.DatabaseAccess.getitems :: Long -> List (PersistentMap Keyword Object)
  native wrapintransaction com.fregeclj.DatabaseAccess.wrapintransaction :: (Object -> a) -> IO (a)
  -- existingamount [idplayer symbol connection]
  pure native existingamount com.fregeclj.DatabaseAccess.existingamount ::  Long -> String -> Object -> Maybe Long
  --updateitem [amount symbol idplayer connection]
  pure native updateitem com.fregeclj.DatabaseAccess.updateitem ::  Long -> String -> Long -> Object -> String  --connection and BigInteger actually
  --insertitem [symbol amount price idplayer connection]
  pure native insertitem com.fregeclj.DatabaseAccess.insertitem ::  String -> Long -> Double -> Long -> Object -> String  --connection and BigInteger actually
  --deleteitem [idplayer symbol connection]
  pure native deleteitem com.fregeclj.DatabaseAccess.deleteitem ::  Long -> String -> Object -> String  --connection and BigInteger actually


maybePrint :: Show a => Maybe a -> IO ()
maybePrint y =  case y of 
                              Nothing -> return ()
                              Just x     = println x        

maybeShow :: Show a => IO (Maybe a) -> IO (String)
maybeShow y = do
                                z <- y
                                case z of 
                                   Nothing -> return ""
                                   Just x     = return $ show x        
                        
                                                                        
--testExistingAmount :: Long -> String -> Maybe Long
--testExistingAmount :: Long -> String -> IO (Maybe String)
testExistingAmount :: Long -> String -> IO (String)
testExistingAmount idplayer symbol = do
                                                                   res <- maybeShow $ DatabaseAccess.wrapintransaction $ DatabaseAccess.existingamount idplayer symbol
                                                                   return res

order :: String -> Long ->Double -> Long -> Object -> IO ()
order symbol amount price idPlayer connection = do 
      let costs = price * fromIntegral amount 
      let cash = DatabaseAccess.existingamount idPlayer "CASH" connection
      case cash of
           Just money -> do
             if (fromIntegral money) >= costs
                then do
                  let deduction = DatabaseAccess.updateitem (round $ ((fromIntegral money) - costs)) "CASH" idPlayer connection
                  let stock = DatabaseAccess.existingamount idPlayer symbol connection
                  case stock of
                       Just amountOfStock -> do
                         let newAmount = amount + amountOfStock    
                         let success = DatabaseAccess.updateitem newAmount symbol idPlayer connection
                         println $ deduction ++ success
                       Nothing -> do
                         let success = DatabaseAccess.insertitem symbol amount price idPlayer connection
                         println $ deduction ++ success
                         return ()
                else return ()
           Nothing -> do
             println "No cash found"
             return ()


{--

runInTransaction connection = do 
                                                          --let success =  DatabaseAccess.updateitem 30000 "CASH" 1 connection
                                                          --println success                                                  
                                                          --let success2 = DatabaseAccess.insertitem "BLUP" 42 3.14 1 connection
                                                          --println success2
                                                          println $ DatabaseAccess.updateitem 40000 "CASH" 1 connection ++ (DatabaseAccess.insertitem "BLEP" 42 3.14 1 connection) ++ DatabaseAccess.deleteitem 1 "BLUP" connection


runInTransaction connection = do 
                                                          let success =  DatabaseAccess.updateitem 20000 "CASH" 1 connection
                                                          println success                                                  
                                                          --success >>= \x -> println x


runInTransaction connection = do 
                                                          success <-  DatabaseAccess.updateitem 20000 "CASH" 1 connection
                                                          println success                                                   
                                                          --success >>= \x -> println x
--}
                                                                                                                                  
main = do
               success <- DatabaseAccess.wrapintransaction $ order "TESTI" 3 2.0 1
               
               -- something needs to be done with the result or it is never evaluated if we declare it as a pure function!
               -- println success
               --asdf <- DatabaseAccess.wrapintransaction $ DatabaseAccess.insertitem "BLUP" 42 3.14 1
               --println asdf 
               z <- testExistingAmount 1 "CASH"  
               println z
               
                              