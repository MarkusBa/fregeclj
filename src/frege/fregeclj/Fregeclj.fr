module fregeclj.Fregeclj where

{-- Idea: Frege sits on top!
     
     Steps if you have clojure code that depends on frege that depends on clojure:
     lein clean
     Change Frege class to not depend on clojure.
     lein fregec
     lein repl (or some other command that compiles the clojure code) like lein compile
     Change Frege class
     lein fregec
     
     Steps if you just call clojure
     lein clean
     lein compile
     lein fregec
     lein repl 
     (import ...)
--}


data PersistentMap k v = native clojure.lang.IPersistentMap where
  pure native empty clojure.lang.PersistentHashMap.EMPTY :: PersistentMap k v
  pure native assoc :: PersistentMap k v -> k -> v -> PersistentMap k v
  pure native valAt :: PersistentMap k v -> k -> v -> v

  fromKVList :: [(k, v)] -> PersistentMap k v
  fromKVList xs = foldl addItem PersistentMap.empty xs where
    addItem m (k, v) = PersistentMap.assoc m k v

data LazySeq v = native clojure.lang.LazySeq

data PersistentList v = native clojure.lang.IPersistentList 
--where
  --pure native empty clojure.lang.PersistentList.EMPTY :: PersistentList v
  --pure native cons :: PersistentList v -> v  -> PersistentList v

data Keyword = native clojure.lang.Keyword    

data DatabaseAccess = native com.fregeclj.DatabaseAccess where
  pure native getitems com.fregeclj.DatabaseAccess.getitems :: Int -> LazySeq (PersistentMap Keyword Object) 
 -- pure native getitems com.fregeclj.DatabaseAccess.getitems :: Int -> [PersistentMap Keyword Object]
 --pure native testkeyword com.fregeclj.DatabaseAccess.testkeyword :: Int -> Keyword 
        
                        
--testFrege ::  [PersistentMap Keyword Object]
--testFrege x = x + 1
testFrege =  DatabaseAccess.getitems 1    

