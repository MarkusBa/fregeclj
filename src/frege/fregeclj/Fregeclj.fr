module fregeclj.Fregeclj where

import frege.control.monad.trans.MonadIO

{-- Idea: Frege sits on top!
     
     Steps if you have clojure code that depends on frege that depends on clojure:
     lein clean
     Change Frege class to not depend on clojure.
     lein fregec
     lein repl (or some other command that compiles the clojure code) like lein compile
     Change Frege class
     lein fregec
     
     Steps if you just call clojure
     lein clean
     lein compile
     lein fregec
     lein repl 
     (import ...)
     
     Even less steps
     lein clean
     lein compile
     lein fregec :run fregeclj.Fregeclj
--}

data List e = native java.util.List where
  native add :: Mutable s (List e) -> e -> ST s Bool
              | Mutable s (List e) -> Int -> e -> ST s ()
  native clear :: Mutable s (List e) -> ST s ()
  native contains :: Mutable s (List e) -> Object -> ST s Bool
  native equals :: Mutable s (List e) -> Object -> ST s Bool
  native get :: Mutable s (List e) -> Int -> ST s e
  native hashCode :: Mutable s (List e) -> ST s Int
  native indexOf :: Mutable s (List e) -> Object -> ST s Int
  native isEmpty :: Mutable s (List e) -> ST s Bool
  native lastIndexOf :: Mutable s (List e) -> Object -> ST s Int
  native remove :: Mutable s (List e) -> Object -> ST s Bool
                 | Mutable s (List e) -> Int -> ST s e
  native set :: Mutable s (List e) -> Int -> e -> ST s e
  native size :: Mutable s (List e) -> ST s Int
  native subList :: Mutable s (List e) -> Int -> Int -> STMutable s (List e)

data PersistentMap k v = native clojure.lang.IPersistentMap where
  pure native empty clojure.lang.PersistentHashMap.EMPTY :: PersistentMap k v
  pure native assoc :: PersistentMap k v -> k -> v -> PersistentMap k v
  pure native valAt :: PersistentMap k v -> k -> v -> v

  fromKVList :: [(k, v)] -> PersistentMap k v
  fromKVList xs = fold addItem PersistentMap.empty xs where
    addItem m (k, v) = PersistentMap.assoc m k v

data LazySeq v = native clojure.lang.LazySeq

data PersistentList v = native clojure.lang.IPersistentList 
--where
  --pure native empty clojure.lang.PersistentList.EMPTY :: PersistentList v
  --pure native cons :: PersistentList v -> v  -> PersistentList v

data Keyword = native clojure.lang.Keyword    

{--
   #^{:static true} [existingamount [long String Object] Long]
              #^{:static true} [updateitem [long String long Object] Integer]
              #^{:static true} [insertitem [String long double long java.sql.Timestamp Object] Integer]
              #^{:static true} [deleteitem [long String Object] Integer]
              #^{:static true} [wrapintransaction [frege.runtime.Fun1] Object]
              #^{:static true} [getitems [long] clojure.lang.LazySeq]
 --}     
 
 -- TODO Stop lying about the methods being pure
                 
data DatabaseAccess = native com.fregeclj.DatabaseAccess where
  pure native getitems com.fregeclj.DatabaseAccess.getitems :: Long -> List (PersistentMap Keyword Object)
  native wrapintransaction com.fregeclj.DatabaseAccess.wrapintransaction :: (Object -> a) -> IO (a)
  pure native existingamount com.fregeclj.DatabaseAccess.existingamount ::  Long -> String -> Object -> Maybe Long
  native updateitem com.fregeclj.DatabaseAccess.updateitem ::  Long -> String -> Long -> Object -> IO ()  --connection and BigInteger actually
  {-- pure native getitems com.fregeclj.DatabaseAccess.getitems :: Int -> List (PersistentMap Keyword Object) 
   pure native getitems com.fregeclj.DatabaseAccess.getitems :: Int -> [PersistentMap Keyword Object]
   pure native testkeyword com.fregeclj.DatabaseAccess.testkeyword :: Int -> Keyword
   --} 

maybePrint :: Show a => Maybe a -> IO ()
maybePrint y =  case y of 
                              Nothing -> return ()
                              Just x     = println x        

maybeShow :: Show a => IO (Maybe a) -> IO (String)
maybeShow y = do
                                z <- y
                                case z of 
                                   Nothing -> return ""
                                   Just x     = return $ show x        
                        
                                                                        
--testExistingAmount :: Long -> String -> Maybe Long
--testExistingAmount :: Long -> String -> IO (Maybe String)
testExistingAmount :: Long -> String -> IO (String)
testExistingAmount idplayer symbol = do
                                                                   res <- maybeShow $ DatabaseAccess.wrapintransaction $ DatabaseAccess.existingamount idplayer symbol
                                                                   return res

                                                                                              
main = do
               success <- DatabaseAccess.wrapintransaction $ DatabaseAccess.updateitem 10000 "CASH" 1
               -- something needs to be done with the result or it is never evaluated if we declare it as a pure function!
               -- println success
               z <- testExistingAmount 1 "CASH"  
               println z
               
                              